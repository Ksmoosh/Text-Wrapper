Mechanizm wyjÄ…tkÃ³w Javy kaÅ¼dy zna i na pozÃ³r nie ma tu jakiejÅ› wielkiej filozofii: co zostaÅ‚o rzucone, prÄ™dzej czy pÃ³Åºniej zostaje zÅ‚apane (choÄ‡by przez standardowy handler wÄ…tku). Co jednak w przypadku, gdy w bloku try, catch, finally pojawi siÄ™ wyjÄ…tek niezÅ‚apany przez klauzulÄ™ catch, a na dodatek zostanie rzucony kolejny wyjÄ…tek z finally? ObsÅ‚uÅ¼one zostanÄ… oba? Jeden z nich? JeÅ›li znasz i rozumiesz odpowiedÅº na to pytanie, moÅ¼esz od razu przejÅ›Ä‡ do sekcji 4 JeÅ›li jednak nie, to zachÄ™cam do dalszego czytania. Najpierw trochÄ™ podstaw dziaÅ‚ania JVM niezbÄ™dnych do zrozumienia zagadnienia.

MichaÅ‚ Zimnicki. Java Tech Lead w ALTEN Polska. Java Technical Leader z wieloletnim doÅ›wiadczeniem w programowaniu w jÄ™zyku Java oraz projektowaniu systemÃ³w rozproszonych. SpecjalnoÅ›Ä‡: szeroko pojÄ™ty â€œperformanceâ€. PrzygodÄ™ z programowaniem zaczynaÅ‚ od Pascala, bÄ™dÄ…c w pierwszej klasie gimnazjum. Å»aden problem go nie przeraÅ¼a. UczestniczyÅ‚ w tworzeniu i rozwoju systemÃ³w do: transportu gotÃ³wki, sprzedaÅ¼y owocÃ³w, lokalizacji, obsÅ‚ugi bankowej, a nawet reklamowania kremu na zmarszczki. Gdy najdzie go wena, lubi zrobiÄ‡ prezentacje na jakiÅ› ciÄ™Å¼szy temat.
1. Podstawy JVM
Wirtualna maszyna Javy jest maszynÄ… wykonujÄ…cÄ… operacje na stosie. Tyle Å¼e stosy sÄ… dwa:
â€“ Stos wywoÅ‚aÅ„ â€“ za kaÅ¼dym razem, gdy wywoÅ‚ywana jest jakakolwiek metoda na ten stos wrzucana jest ramka skÅ‚adajÄ…ca siÄ™ w uproszczeniu z:

kopii wartoÅ›ci parametrÃ³w wywoÅ‚ania[1],Â 
przestrzeni na zmienne lokalne,Â 
stosu dla argumentÃ³w
dodatkowych danych ramki.Â 

KaÅ¼dy wÄ…tek ma swÃ³j osobny stos wywoÅ‚aÅ„.
â€“ Stos dla argumentÃ³w â€“ 32 bitowa[2] kolejka LIFO, na ktÃ³rÄ… wrzucane sÄ… argumenty potrzebne do wykonywania instrukcji. Dla przykÅ‚adu dodawania jest operacjÄ… dwuargumentowÄ…, zatem aby dodaÄ‡ 3 do 4 najpierw na stos wrzucane sÄ… wartoÅ›ci 3 i 4, a potem wykonywana jest operacja dodawania ktÃ³ra pobiera 2 gÃ³rne wartoÅ›ci ze stosu, sumuje je, a wynik wrzuca na gÃ³rÄ™. Dla uproszczenia w dalszej czÄ™Å›ci artykuÅ‚u bÄ™dÄ™ go nazywaÅ‚ po prostu â€stosemâ€.
Istotnym dla nas jest jeszcze plik klasy, ktÃ³ry oprÃ³cz kodu bajtowego metod zawiera rÃ³wnieÅ¼ masÄ™ dodatkowych informacji potrzebnych do ich prawidÅ‚owego wykonania.

Rys. 1.1 PrzykÅ‚adowa klasa

Rys. 1.2. Kod bajtowy Javy dla klasy z rys. 1.1
W pokazanym fragmencie interesujÄ…cÄ… czÄ™Å›ciÄ… jest tabela wyjÄ…tkÃ³w (exception table) zwiÄ…zana z blokiem try. SkÅ‚ada siÄ™ ona z: numeru instrukcji poczÄ…tkowej (from), numeru instrukcji koÅ„cowej (to), klasy wyjÄ…tku (type) i miejsca, od ktÃ³rego naleÅ¼y przejÅ›Ä‡ w przypadku wystÄ…pienia danej klasy wyjÄ…tku (target). Wartym uwagi jest fakt, Å¼e blok try nie ma wyraÅºnej reprezentacji w kodzie bajtowym metody. WidaÄ‡ wiÄ™c jasno, iÅ¼ wejÅ›cie do bloku try nie jest zwiÄ…zane z Å¼adnÄ… operacjÄ…, co z punktu widzenia wydajnoÅ›ci udowadnia, Å¼e samo uÅ¼ycie try jest darmowe.
Dodatkowo widzimy tabele definiujÄ…cÄ…, ktÃ³re operacje odpowiadajÄ… ktÃ³remu numerowi linii w pliku .java. Jest to potrzebne by zbudowaÄ‡ stack trace dajÄ…cy nam bezcenne informacje o dokÅ‚adnym miejscu wystÄ…pienia wyjÄ…tku w czytelnej dla programisty postaci. Rozczytanie tej tabeli na pierwszy rzut oka nie jest Å‚atwe. Pierwsza wartoÅ›Ä‡ mÃ³wi o numerze linii z pliku .java, nastÄ™pna to poczÄ…tek przedziaÅ‚u instrukcji, dla ktÃ³rego ta linia siÄ™ zaczyna. PrzedziaÅ‚ koÅ„czy siÄ™ na wartoÅ›ci nastÄ™pnego wpisu w tabeli. Tak wiÄ™c wartoÅ›ci 0-7 odpowiadajÄ… System.out.println(â€inside tryâ€) (linia 7) wartoÅ›ci 8-15 throw new ThreadDeath() (linia 8) itd.
By znaleÅºÄ‡ numer linii, z ktÃ³rej zostaÅ‚ rzucony wyjÄ…tek wystarczy przeszukaÄ‡ tabelÄ™ od koÅ„ca sprawdzajÄ…c czy numer operacji jest wiÄ™kszy niÅ¼ druga wartoÅ›Ä‡ z tabeli. Tyle â€suchejâ€ wiedzy nam wystarczy do przeÅ›ledzenia jak dziaÅ‚a mechanizm wyjÄ…tkÃ³w.
2. DziaÅ‚anie
ZaÅ‚Ã³Å¼my, Å¼e gdzieÅ› zostaÅ‚a wywoÅ‚ana nasza metoda â€tryCatchFinally()â€. W wÄ…tku, w ktÃ³rym zostaÅ‚a ona uruchomiona tworzona jest ramka, kopiowane sÄ… wartoÅ›ci parametrÃ³w [3] oraz inicjalizowane dodatkowe pola. NastÄ™pnie ramka wrzucana jest na stos wywoÅ‚aÅ„. WskaÅºnik wykonywanej instrukcji [4] przenoszony jest na pierwszÄ… instrukcjÄ™ w naszej metodzie. Instrukcja jest wykonywana, wskaÅºnik przechodzi do nastÄ™pnej i tak aÅ¼ do wystÄ…pienia jednej z dwÃ³ch sytuacji:Â 

napotkania operacji return,
wystÄ…pienia bÄ…dÅº rzucenia wyjÄ…tku.

W pierwszym przypadku ramka jest usuwana ze stosu wywoÅ‚aÅ„, a zwracana wartoÅ›Ä‡ metody (jeÅ›li istnieje) jest wrzucana na stos dla argumentÃ³w ramki poprzedniej (czyli tej, ktÃ³ra odpowiada metodzie, z ktÃ³rej zostaÅ‚a wywoÅ‚ana nasza â€tryCatchFinally()â€) i ten proces jest kontynuowany. Co jednak, gdy wyjÄ…tek zostanie rzucony? Wtedy z pomocÄ… przychodzi nam tabela wyjÄ…tkÃ³w. IterujÄ…c po kolejnych wierszach tabeli porÃ³wnywana jest wartoÅ›Ä‡ wskaÅºnika obecnie wykonywanej instrukcji z zakresem zdefiniowanym w rekordzie. Dodatkowo porÃ³wnywana jest klasa wyjÄ…tku z tÄ… w wierszu â€“ jeÅ›li jest jej pochodnÄ…, wtedy nastÄ™puje przesuniÄ™cie wskaÅºnika instrukcji do miejsca z rekordu i wykonywanie operacji dalej, jakby nic siÄ™ nie staÅ‚o â€“ wyjÄ…tek wszakÅ¼e zostaÅ‚ zÅ‚apany. 
Innymi sÅ‚owy: gdy zostanie rzucony wyjÄ…tek, maszyna patrzy, czy zostaÅ‚ wyrzucony z linii, ktÃ³ra objÄ™ta jest mechanizmem jego â€Å‚apaniaâ€, nastÄ™pnie sprawdza, czy dla jego typu jest przewidziany jakiÅ› kod, ktÃ³ry naleÅ¼y wykonaÄ‡. JeÅ›li tak, to przeskakuje na jego poczÄ…tek i zaczyna go wykonywaÄ‡. Co jednak w przypadku, gdy wyjÄ…tek nie zostanie dopasowany do Å¼adnego z rekordÃ³w w tabeli? Ramka zostaje usuniÄ™ta i proces zostaje ponawiany dla nastÄ™pnej ramki na stosie wywoÅ‚aÅ„. Dzieje siÄ™ tak aÅ¼ wyjÄ…tek zostanie zÅ‚apany, lub dojdziemy do koÅ„ca stosu. Wtedy uruchamiany jest handler dla niezÅ‚apanych wyjÄ…tkÃ³w, a gdy siÄ™ on wykona, wÄ…tek jest koÅ„czony.
No dobra. TÅ‚umaczy to dziaÅ‚anie try, catch ale co z finally? A no finally to takie sprytne uÅ¼ycie tego samego mechanizmu tylko przez kompilator. Ale po kolei. Specyfikacja mÃ³wi, Å¼e finally zawsze siÄ™ nam wykona [5]. Å»eby byÅ‚o to moÅ¼liwe kompilator [6] faktycznie kopiuje treÅ›Ä‡ bloku finally do kaÅ¼dej z czÄ™Å›ci try, catch. Obrazuje to przykÅ‚ad poniÅ¼ej.

Rys. 2.1. Kod przykÅ‚adowej klasy

Rys. 2.2. Kod bajtowy Javy dla metody z rys. 2.1
Tak wiÄ™c przy normalnym dziaÅ‚aniu blok finally zachowuje siÄ™ jakby byÅ‚ po prostu zwyczajnÄ… czÄ™Å›ciÄ… metody i jego wykonanie nie wiÄ…Å¼e siÄ™ z Å¼adnym spadkiem wydajnoÅ›ci. Jako Å¼e jest on rÃ³wnieÅ¼ kopiowany do blokÃ³w catch, jeÅ›li wyjÄ…tek zostanie zÅ‚apany kod z finally wykona siÄ™ normalnie. Co jednak, gdy wyjÄ…tek nie zostanie zÅ‚apany lub wyjÄ…tek zostanie rzucony z bloku catch? WÅ‚aÅ›nie od tego jest ostatni blok (zaznaczony na zielono) i wpisy w tabeli wyjÄ…tkÃ³w:

Rys. 2.3. Tabela wyjÄ…tkÃ³w dla metody z rys. 2.1
MÃ³wiÄ… nam dokÅ‚adnie tak: jeÅ›li z bloku try, lub dowolnego catch zostanie rzucony wyjÄ…tek, ktÃ³ry nie jest obsÅ‚ugiwany przez Å¼adne inne mechanizmy przejdÅº do ostatniego finally. Jak widzimy zawiera on, oprÃ³cz funkcjonalnoÅ›ci napisanej przez developera, dodatkowe instrukcje. Potrzebne sÄ… one do tymczasowego przetrzymania rzuconego wyjÄ…tku (wszakÅ¼e skierowaÅ‚ nas tutaj jakiÅ› niezÅ‚apany), a nastÄ™pnie po sukcesywnym wykonaniu wnÄ™trza bloku jego ponowne rzucenie. WrÃ³Ä‡my wiÄ™c do pytania z poczÄ…tku artykuÅ‚u: co siÄ™ stanie, kiedy z bloku finally zostanie rzucony wyjÄ…tek? Najpierw przeszukana zostanie tablica wyjÄ…tkÃ³w, gdzie nie zostanie on znaleziony [7], wiÄ™c ramka zostanie zwiniÄ™ta (wszelkie dane znajdujÄ…ce siÄ™ na stosie dla argumentÃ³w, zmienne lokalne itd. zostanÄ… usuniÄ™te) i kontrola przejdzie do nastÄ™pnej ramki na stosie wywoÅ‚aÅ„, gdzie proces zostanie ponowiony itd. 
Co jednak, gdy akurat rzucony on zostanie z naszego dodatkowego bloku, w ktÃ³rym jak pamiÄ™tamy mamy czasowo przetrzymany niezÅ‚apany wyjÄ…tek do ponownego rzucenia? A tu, zgodnie z logikÄ… wczeÅ›niej opisanÄ…, informacja o nim zostanie bezpowrotnie utracona wraz z usuniÄ™ciem ramki. Mechanizm obsÅ‚ugi wyjÄ…tkÃ³w zajmowaÅ‚ siÄ™ bÄ™dzie bowiem tym, ktÃ³ry wÅ‚aÅ›nie zostaÅ‚ rzucony. ZauwaÅ¼cie, Å¼e z punktu widzenia wirtualnej maszyny nie istnieje rozgraniczenie na rodzaje wyjÄ…tkÃ³w ani nawet specjalne traktowanie bÅ‚Ä™dÃ³w errors, jest to coÅ› o czym warto pamiÄ™taÄ‡.
Czy to juÅ¼ koniec? JeÅ›li chodzi o sam mechanizm to tak. Java 7 wprowadziÅ‚a nam coÅ› takiego jak â€stÅ‚umiony wyjÄ…tekâ€ (suppressed exception). I teraz bÄ™dzie o nim mowa.
3. StÅ‚umiony wyjÄ…tek
Specyfikacja jÄ™zyka Java 7 definiuje mechanizm try with resources, ktÃ³ry znaczÄ…co upraszcza korzystanie z bibliotek, ktÃ³re po inicjalizacji mogÄ… pozostawiaÄ‡ zasoby w nieokreÅ›lonym stanie. Dla nich trzeba byÅ‚o zawsze definiowaÄ‡ blok finally, w ktÃ³rym zasoby te byÅ‚y odpowiednio zamykane. PowodowaÅ‚o to produkcjÄ™ identycznego kodu, a czÄ™sto nawet dodatkowe zagnieÅ¼dÅ¼enia blokÃ³w try finally w finally. Z pomocÄ… przyszÅ‚o try with resources, ktÃ³re po wyjÅ›ciu z bloku try, catch uruchamia implementacje metody close() z interfejsu AutoCloseable niejako w ukrytym bloku finally. Jak to z JavÄ… bywa, tutaj teÅ¼ moÅ¼emy spodziewaÄ‡ siÄ™ jakiejÅ› magii kompilatora w miejsce zmian na poziomie wirtualnej maszyny. Najlepiej zobrazuje to przykÅ‚ad: 3.1 przedstawiajÄ…cy metodÄ™ napisanÄ… w Javie, a nastÄ™pnie poddanÄ… procesowi kompilacji i dekompilacji.


Rys. 3.1. Kod przykÅ‚adowej metody wykorzystujÄ…cej mechanizm try with resources



Rys. 3.2. Kod metody z rys. 3.1. poddany procesowi kompilacji i dekompilacji
Jak widzimy efekt finalny znaczÄ…co rÃ³Å¼ni siÄ™ od tego co faktycznie deweloper â€zakodziÅ‚â€. SprÃ³bujmy rozczytaÄ‡ co tak wÅ‚aÅ›ciwie siÄ™ tutaj dzieje.
PierwszÄ… rzeczÄ…, ktÃ³ra rzuca nam siÄ™ w oczy jest dodatkowo zagnieÅ¼dÅ¼ony blok try, catch finally. Ale zanim do niego przejdziemy zaczniemy od gÃ³ry. Pierwsze 2 linijki zawierajÄ… kod, ktÃ³ry zawarliÅ›my w inicjalizacji bloku, co jest raczej logiczne, bo gdzieÅ› on wykonaÄ‡ siÄ™ musi. Zastanawia deklaracja zmiennej â€var2â€, ktÃ³ra bÄ™dzie stanowiÄ‡ tymczasowy kubeÅ‚ek na dodatkowy wyjÄ…tek, ktÃ³ry moÅ¼e zostaÄ‡ rzucony w trakcie wykonywania naszych operacji. Deklarowany jest on przed blokiem try abyÅ›my mieli do niego dostÄ™p w nastÄ™pujÄ…cych blokach catch i finally. 
PrzejdÅºmy dalej do faktycznego wywoÅ‚ania naszego kodu. JeÅ›li zostanie rzucony jakikolwiek wyjÄ…tek przy jego wykonywaniu, trafiamy do jedynego bloku catch, gdzie caÅ‚a logika opiera siÄ™ na zapisaniu jego do naszej lokalnej zmiennej â€var2â€ i rzuceniu go ponownie. Gdy sterowanie przejdzie dalej, do bloku finally, zanim wykona siÄ™ metoda close() nastÄ…pi sprawdzenie czy jest to normalne wykonanie, czy moÅ¼e jednak coÅ› poszÅ‚o nie tak i juÅ¼ jakiÅ› wyjÄ…tek zostaÅ‚ rzucony sprawdzajÄ…c istnienie zmiennej â€var2â€. Zgodnie z prawem Murphiego â€JeÅ¼eli coÅ› moÅ¼e siÄ™ nie udaÄ‡, to siÄ™ nie udaâ€ musimy zabezpieczyÄ‡ siÄ™ przed sytuacjÄ…, w ktÃ³rej nasza metoda close() rzuci wyjÄ…tkiem. Powstaje wtedy problem rzucenia wyjÄ…tkiem w przypadku, gdy juÅ¼ jakiÅ› rzucony zostaÅ‚. W takiej sytuacji wyjÄ…tek z close() nie jest usuwany wraz z ramkÄ… jak w przypadku opisywanym wczeÅ›niej, a jest podpinany pod niego jako suppressed. 
NastÄ™pne kroki wykonania sÄ… takie same jak w opisywanym wyÅ¼ej mechanizmie. KtoÅ› mÃ³gÅ‚by zapytaÄ‡: â€po co to wszystko?â€. OdpowiedÅº jest prosta: w powyÅ¼szym podejÅ›ciu nic nie ginie. Wszystkie informacje o wyjÄ…tkach pozostajÄ… zachowane, a wszystko jest przezroczyste dla dewelopera. Dlaczego wiÄ™c nie wprowadziÄ‡ czegoÅ› podobnego dla klasycznego bloku try, catch, finally? Tutaj sprawa nie jest juÅ¼ taka oczywista. Mimo Å¼e wymagaÅ‚oby to zmiany tylko na poziomie kompilatora, wprowadzaÅ‚o by to nieÅ›cisÅ‚oÅ›ci. Ten sam kod skompilowany pod JavÄ™ 6 dziaÅ‚aÅ‚by inaczej niÅ¼ ten zbudowany za pomocÄ… kompilatora Javy 7+, a to mogÅ‚oby prowadziÄ‡ do problemÃ³w z migracjÄ…, nie mÃ³wiÄ…c juÅ¼ o puÅ‚apce dla nieÅ›wiadomych programistÃ³w.
4. Koszt obliczeniowy wyjÄ…tkÃ³w
Z punktu widzenia wydajnoÅ›ci przejÅ›cie normalna Å›cieÅ¼kÄ… (bez rzucania wyjÄ…tkÃ³w) nie kosztuje nic, gdyÅ¼ wejÅ›cie i wyjÅ›cie z bloku try nie jest zwiÄ…zane z Å¼adnÄ… operacjÄ… wirtualnej maszyny. Sytuacja zmienia siÄ™ w momencie pojawienia siÄ™ wyjÄ…tku. Przeszukanie tablicy nie jest jakoÅ› specjalnie kosztowne, gdyÅ¼ znajduje siÄ™ na niej zwykle tylko kilka rekordÃ³w. Koszt skoku do odpowiedniej instrukcji rÃ³wnieÅ¼ jest pomijalny [8]. Czy wiÄ™c moÅ¼emy rzucaÄ‡ wyjÄ…tkami do woli nie przejmujÄ…c siÄ™ narzutem obliczeniowym? I tak i nie. 
Sam mechanizm nie kosztuje nas zbyt wiele, ale za to wyjÄ…tek, ktÃ³ry naleÅ¼y stworzyÄ‡ kosztuje bardzo duÅ¼o. PrzeÅ›ledÅºmy wiÄ™c, gdzie znikajÄ… nasze cykle procesora. Za kaÅ¼dym razem, kiedy tworzymy wyjÄ…tek jego Å›lad stosu wywoÅ‚aÅ„ stack trace musi zostaÄ‡ wypeÅ‚niony [9]. Å»eby to zrobiÄ‡ wirtualna maszyna musi przejÅ›Ä‡ po kaÅ¼dej ramce znajdujÄ…cej siÄ™ na stosie wywoÅ‚aÅ„, pobraÄ‡ wskaÅºnik na obecnie wywoÅ‚ywanÄ… instrukcjÄ™, dopasowaÄ‡ linijkÄ™ kodu Java do tej instrukcji i za ich pomocÄ… zbudowaÄ‡ niemutowany rekord w tabeli Å›ladu stosu wywoÅ‚aÅ„. Jest to sporo roboty i jej iloÅ›Ä‡ jest bezpoÅ›rednio zaleÅ¼na od rozmiaru stosu wywoÅ‚aÅ„. Ile to znaczy â€sporoâ€? 
Aleksey ShipilÃ«v przeprowadziÅ‚ bardzo dokÅ‚adne pomiary [10], z ktÃ³rymi polecam siÄ™ zapoznaÄ‡ (literatura nie naleÅ¼y do najlÅ¼ejszych, ale moim zdaniem warto), i wynika z nich, Å¼e rzucenie nowo utworzonym wyjÄ…tkiem jest Å›rednio miÄ™dzy 10^3, a 10^4 razy wolniejsze niÅ¼ wybranie Å›cieÅ¼ki za pomocÄ… if else. Z tego teÅ¼ powodu powstaÅ‚y rozwiÄ…zania takie jak re-uÅ¼ywanie obiektu wyjÄ…tku, ktÃ³re znaczÄ…co redukujÄ… ten problem jednak nie rozwiÄ…zujÄ… go w caÅ‚oÅ›ci. Co nam jednak dajÄ… te dane? Powszechnie powtarza siÄ™, Å¼e wyjÄ…tki powinny byÄ‡ uÅ¼ywane w sytuacjach â€wyjÄ…tkowychâ€. Czasami ciÄ™Å¼ko jednak okreÅ›liÄ‡, czy sytuacja jest naprawdÄ™ wyjÄ…tkowa. Teraz mamy juÅ¼ pewnÄ… receptÄ™: jeÅ›li dana sytuacja wystÄ™puje czÄ™Å›ciej niÅ¼ raz na 1000 przypadkÃ³w, to sytuacjÄ… wyjÄ…tkowÄ… nie jest.
I tak oto dobrnÄ™liÅ›my do koÅ„ca. Dla tych co wytrwali zdradzÄ™, Å¼e dziÄ™ki wiedzy przedstawionej w tym artykule udaÅ‚o mi siÄ™ zagiÄ…Ä‡ niejednego weryfikatora technicznego i efektywnie wynegocjowaÄ‡ wiÄ™kszÄ… pensjÄ™. WiÄ™c jeÅ›li zastanawiacie do czego ta wiedza moÅ¼e wam siÄ™ przydaÄ‡, to chociaÅ¼ do tego ğŸ™‚
Adnotacje:
[1] W przypadku obiektÃ³w, kopiowane sÄ… ich referencje
[2] Specyfikacja JVM definiuje stos jako 32 bitowy, nie mniej jednak, Å¼eby radziÄ‡ sobie z 64 bitowymi adresami pamiÄ™ci wiÄ™kszoÅ›Ä‡ obecnych implementacji uÅ¼ywa 64 bitowego stosu.
[3] Mimo Å¼e metoda deklaruje, Å¼e nie przyjmuje Å¼adnych parametrÃ³w, kopiowana jest wartoÅ›Ä‡ referencji this, gdyÅ¼ ciÄ…gle pozostaje ona metoda wirtualnÄ…. Taka operacja nie zaszÅ‚aby w przypadku, gdyby byÅ‚a metodÄ… statycznÄ…
[4] Tak naprawdÄ™ jest to rejestr trzymajÄ…cy index obecnie wywoÅ‚ywanej operacji
[5] OprÃ³cz wyjÄ…tkowych sytuacji w ktÃ³rych i tak aplikacja nie byÅ‚aby juÅ¼ do odratowania
[6] Od Javy 7, wczeÅ›niej uÅ¼ywaÅ‚ niezbyt eleganckiej operacji _jsr
[7] No chyba ze mieliÅ›my zagnieÅ¼dÅ¼ony blok finally w innym bloku try, catch
[8] Gdyby nie byÅ‚, to nikt z JVM by nie korzystaÅ‚ bo jest on podstawÄ… wielu instrukcji poczÄ…wszy od if else.
[9] MoÅ¼na to wyÅ‚Ä…czyÄ‡ flagÄ… JVM, jednak jest wysoce niezalecane, bo efektywnie tracone sÄ… informacje doÅ›Ä‡ niezbÄ™dne przy prÃ³bie debugowania.
[10] shipilev.net.